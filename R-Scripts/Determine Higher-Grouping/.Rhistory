Proc_dist = read.table("Proc_distances_ban_pim_oph_cte.txt", header=T)
data = data.frame(species1, subfam1, PCA$pc.scores[,1:25])
# Compute distances and hierarchical clustering
de <- dist(scale(data[c(3:27)]), method = "euclidean")
## Ward's minimum variance method
hd <- hclust(de, method = "ward.D2")
hd$labels = paste (subfam1,species1, sep = "_", collapse = NULL, recycle0 = FALSE)
# Convert hclust into a dendrogram and plot
hce <- as.dendrogram (hd)
require("dendextend") ## needs a dendrogram
par(mar= c(10,3,1,1))
my_colors1 <- ifelse(substr(hd$labels,1,6)=="banchi", "cyan",ifelse(substr(hd$labels,1,6)=="gelina","green", ifelse(substr(hd$labels,1,6)=="ichneu", "red",ifelse(substr(hd$labels,1,6)=="ophion", "darkblue",ifelse(substr(hd$labels,8,13)== "fossil", "magenta", "yellow" )))))
hce %>%
set("labels_col", value = c("skyblue", "darkorange", "grey","darkorange4","deepskyblue4",
"darkolivegreen3","darkorchid1","firebrick","gold1","aquamarine2","brown2","darkseagreen3","black"), k=13) %>%
set("branches_k_color", value = c("skyblue", "darkorange", "grey","darkorange4","deepskyblue4",
"darkolivegreen3","darkorchid1","firebrick","gold1","aquamarine2","brown2","darkseagreen3","black"),k = 13) %>%
set("labels_cex", 0.7)  %>%
set("leaves_pch", 19)  %>%
set("nodes_cex", 0.4) %>%
plot(axes=FALSE)
# Add the colored bar
colored_bars(colors = my_colors1, dend = hce, rowLabels = "subfam1")
legend("topright", legend=levels(subfam1), col= c("cyan", "green", "red", "darkblue", "yellow"), pch=15)
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
require(Morpho)
require(rgl)
options(rgl.useNULL = TRUE) # Suppress the separate window.
knitr::knit_hooks$set(webgl = hook_webgl)
library(geomorph)
setwd("~/GitHub/Ichneumonidae/R-Scripts/Determine Higher-Crouping")
landmark = readland.tps("blockcourse_highersub.tps",specID = "ID", readcurves = T, warnmsg = TRUE)
##      define classifiers (subfam or tribes)
species = as.factor( substr( dimnames(landmark)[[3]], 1, 6))
subfam = as.factor( substr( dimnames(landmark)[[3]], 8, 13))
areolet = as.factor( substr( dimnames(landmark)[[3]], 15, 15))
tribe = as.factor( substr( dimnames(landmark)[[3]], 17, 19))
##      define Semilandmarks, first LM is the start, last one the end (those are both
##      fixed landmarks, in between are the semilandmarks):
sliders = define.sliders(c(15,22:29,16))
##      procrustes fit - "superimposition" - rotates and scales the landmarks to their closest distance,
##      minimizing the shape and size difference:
proD<-gpagen(landmark, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
use= c("pimpli", "banchi", "gelina", "ophion", "ichneu")
reduced<- proD$coords[,,subfam%in% use]
pro_red<-gpagen(reduced, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
subfam1<-as.factor(substr(dimnames(pro_red$coords)[[3]],8,13))
species1<-as.factor(substr(dimnames(pro_red$coords)[[3]],1,6))
tribe1<-as.factor(substr(dimnames(pro_red$coords)[[3]],17,19))
PCA <-plotTangentSpace(pro_red$coords, groups=subfam1, legend=T)
## the more beautiful version:
mat <- matrix(c(4,5,0,1,1,2,1,1,3), 3)
layout(mat, widths=c(1,1,1), heights=c(1,1,1))# set the size of the rows and columns
par(mar=c(4, 4, 1, 1)) # sets the margins
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=subfam1, asp=T, las=1,pch=16, cex=1.5)
legend("topright", legend= levels(subfam1), col=palette(), pch=rep(19,14) )
segments(min(PCA$pc.scores[,1]), 0,  max(PCA$pc.scores[,1]),0, col="grey", lty="dashed")
segments(0, min(PCA$pc.scores[,2]), 0,  max(PCA$pc.scores[,2]), col="grey", lty="dashed")
# in order to name individuals: text(PCA$pc.scores[,1],PCA$pc.scores[,2], species)
ref <- mshape(proD$coords)
#qw= c(1,4,2,6,5,7,3)
par(mar = c(0,0,0,0)) # sets the margins
plotRefToTarget(ref,PCA$pc.shapes$PC1min)
# Item 3
plotRefToTarget(ref,PCA$pc.shapes$PC1max)
# Item 4
plotRefToTarget(ref,PCA$pc.shapes$PC2max)
# Item 5
plotRefToTarget(ref,PCA$pc.shapes$PC2min)
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
my_colours <- c("red", "cyan", "yellow", "purple", "green")[subfam1]
# plot the CVA
plot(cva$CVscores, col=my_colours, pch=16,asp=1,
xlab=paste("1st canonical axis", paste(round(cva$Var[1,2],1),"%")),
ylab=paste("2nd canonical axis", paste(round(cva$Var[2,2],1),"%")))
legend("topright", legend=levels(subfam1), col = c("red", "cyan", "yellow", "purple", "green"), pch=16)
require(car)
for(ii in 1:length(levels(subfam1))){
dataEllipse(cva$CVscores[subfam1==levels(subfam1)[ii],1],
cva$CVscores[subfam1==levels(subfam1)[ii],2],
add=TRUE,levels=.95, col=c("red", "cyan", "yellow", "purple", "green")[ii])}
text(cva$CVscores[200,1], cva$CVscores[200,2], as.character(species1[200]), col="black", cex=1, pos=4)
text(cva$CVscores[49,1], cva$CVscores[49,2], as.character(species1[49]), col="black", cex=1, pos=4)
library(Evomorph)
inlist = list(pro_red$coords [,,])
for ( j in 1: dim(pro_red$coords )[3] )
inlist[[j]] = pro_red$coords [,,j]
ID = paste (subfam1,species1, sep = "_", collapse = NULL, recycle0 = FALSE)
### PC1 for PC1dist thingy.. for empty matrix: ###################
PCA_sc<-PCA$pc.scores
row.names(PCA_sc) = ID
PCdist = as.matrix( dist(PCA_sc))
###  make empty matrix
Proc_dist= matrix( NA, dim(PCA_sc)[1], dim(PCA_sc)[1] )
colnames(Proc_dist) = ID
rownames(Proc_dist) = ID
###  make a loop : calculate proc distances for each row.
Proc_dist
for ( i in 1:length(ID)){
Proc_dist[i,] = ShapeDist(inlist, inlist[[i]])
}
write.table(Proc_dist,"Proc_distances_ban_pim_oph_cte.txt", sep=" ",row.names = TRUE, col.names = TRUE)
###################################################################
Proc_dist = read.table("Proc_distances_ban_pim_oph_cte.txt", header=T)
data = data.frame(species1, subfam1, PCA$pc.scores[,1:25])
# Compute distances and hierarchical clustering
de <- dist(scale(data[c(3:27)]), method = "euclidean")
## Ward's minimum variance method
hd <- hclust(de, method = "ward.D2")
hd$labels = paste (subfam1,species1, sep = "_", collapse = NULL, recycle0 = FALSE)
# Convert hclust into a dendrogram and plot
hce <- as.dendrogram (hd)
require("dendextend") ## needs a dendrogram
par(mar= c(10,3,1,1))
Label <- hce%>%labels
my_colors1 = matrix( NA, dim(Proc_dist))
for(i in 1:length(row.names(Proc_dist))){
my_colors1[i] <- switch(substr(Label[i],1,6), "banchi" = "cyan", "pimpli" = "yellow", "gelina" = "green", "ophion" = "darkblue", "ichneu" = "red")
}
hce %>%
set("labels_col", value =  my_colors1) %>%
set("branches_k_color", value = c("skyblue", "darkorange", "grey","darkorange4","deepskyblue4",
"darkolivegreen3","darkorchid1","firebrick","gold1","aquamarine2","brown2","darkseagreen3","black"),k = 13) %>%
set("labels_cex", 0.7)  %>%
set("leaves_pch", 19)  %>%
set("nodes_cex", 0.4) %>%
hang.dendrogram(hang_height = .8) %>%
plot(axes=FALSE, main= "Dendrogram with ward.D2", horiz = TRUE)
# Add the colored bar
#colored_bars(colors = my_colors1, rowLabels = "subfam")
legend("topleft", legend=levels(subfam1), col= c("cyan", "green", "red", "darkblue", "yellow"), pch=15)
require("dendextend") ## needs a dendrogram
par(mar= c(10,3,1,1))
Label <- hce%>%labels
my_colors1 = matrix( NA, dim(Proc_dist))
for(i in 1:length(row.names(Proc_dist))){
my_colors1[i] <- switch(substr(Label[i],1,6), "banchi" = "cyan", "pimpli" = "yellow", "gelina" = "green", "ophion" = "darkblue", "ichneu" = "red")
}
hce %>%
set("labels_col", value =  my_colors1) %>%
set("branches_k_color", value = c("skyblue", "darkorange", "grey","darkorange4","deepskyblue4",
"darkolivegreen3","darkorchid1","firebrick","gold1","aquamarine2","brown2","darkseagreen3","black"),k = 13) %>%
set("labels_cex", 0.7)  %>%
set("leaves_pch", 19)  %>%
set("nodes_cex", 0.4) %>%
plot(axes=FALSE, main= "Dendrogram with ward.D2", horiz = TRUE)
# Add the colored bar
#colored_bars(colors = my_colors1, rowLabels = "subfam")
legend("topleft", legend=levels(subfam1), col= c("cyan", "green", "red", "darkblue", "yellow"), pch=15)
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
require(Morpho)
require(rgl)
options(rgl.useNULL = TRUE) # Suppress the separate window.
knitr::knit_hooks$set(webgl = hook_webgl)
library(geomorph)
setwd("~/GitHub/Ichneumonidae/R-Scripts/Determine Higher-Crouping")
landmark = readland.tps("blockcourse_highersub.tps",specID = "ID", readcurves = T, warnmsg = TRUE)
##      define classifiers (subfam or tribes)
species = as.factor( substr( dimnames(landmark)[[3]], 1, 6))
subfam = as.factor( substr( dimnames(landmark)[[3]], 8, 13))
areolet = as.factor( substr( dimnames(landmark)[[3]], 15, 15))
tribe = as.factor( substr( dimnames(landmark)[[3]], 17, 19))
##      define Semilandmarks, first LM is the start, last one the end (those are both
##      fixed landmarks, in between are the semilandmarks):
sliders = define.sliders(c(15,22:29,16))
##      procrustes fit - "superimposition" - rotates and scales the landmarks to their closest distance,
##      minimizing the shape and size difference:
proD<-gpagen(landmark, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
use= c("pimpli", "banchi", "gelina", "ophion", "ichneu")
reduced<- proD$coords[,,subfam%in% use]
pro_red<-gpagen(reduced, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
subfam1<-as.factor(substr(dimnames(pro_red$coords)[[3]],8,13))
species1<-as.factor(substr(dimnames(pro_red$coords)[[3]],1,6))
tribe1<-as.factor(substr(dimnames(pro_red$coords)[[3]],17,19))
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
require(Morpho)
require(rgl)
options(rgl.useNULL = TRUE) # Suppress the separate window.
knitr::knit_hooks$set(webgl = hook_webgl)
library(geomorph)
setwd("~/GitHub/Ichneumonidae/R-Scripts/Determine Higher-Crouping")
landmark = readland.tps("blockcourse_highersub.tps",specID = "ID", readcurves = T, warnmsg = TRUE)
##      define classifiers (subfam or tribes)
species = as.factor( substr( dimnames(landmark)[[3]], 1, 6))
subfam = as.factor( substr( dimnames(landmark)[[3]], 8, 13))
areolet = as.factor( substr( dimnames(landmark)[[3]], 15, 15))
tribe = as.factor( substr( dimnames(landmark)[[3]], 17, 19))
##      define Semilandmarks, first LM is the start, last one the end (those are both
##      fixed landmarks, in between are the semilandmarks):
sliders = define.sliders(c(15,22:29,16))
##      procrustes fit - "superimposition" - rotates and scales the landmarks to their closest distance,
##      minimizing the shape and size difference:
proD<-gpagen(landmark, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
use= c("pimpli", "banchi", "phygad", "ophion", "ichneu")
reduced<- proD$coords[,,subfam%in% use]
pro_red<-gpagen(reduced, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
subfam1<-as.factor(substr(dimnames(pro_red$coords)[[3]],8,13))
species1<-as.factor(substr(dimnames(pro_red$coords)[[3]],1,6))
tribe1<-as.factor(substr(dimnames(pro_red$coords)[[3]],17,19))
PCA <-plotTangentSpace(pro_red$coords, groups=subfam1, legend=T)
## the more beautiful version:
mat <- matrix(c(4,5,0,1,1,2,1,1,3), 3)
layout(mat, widths=c(1,1,1), heights=c(1,1,1))# set the size of the rows and columns
par(mar=c(4, 4, 1, 1)) # sets the margins
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=subfam1, asp=T, las=1,pch=16, cex=1.5)
legend("topright", legend= levels(subfam1), col=palette(), pch=rep(19,14) )
segments(min(PCA$pc.scores[,1]), 0,  max(PCA$pc.scores[,1]),0, col="grey", lty="dashed")
segments(0, min(PCA$pc.scores[,2]), 0,  max(PCA$pc.scores[,2]), col="grey", lty="dashed")
# in order to name individuals: text(PCA$pc.scores[,1],PCA$pc.scores[,2], species)
ref <- mshape(proD$coords)
#qw= c(1,4,2,6,5,7,3)
par(mar = c(0,0,0,0)) # sets the margins
plotRefToTarget(ref,PCA$pc.shapes$PC1min)
# Item 3
plotRefToTarget(ref,PCA$pc.shapes$PC1max)
# Item 4
plotRefToTarget(ref,PCA$pc.shapes$PC2max)
# Item 5
plotRefToTarget(ref,PCA$pc.shapes$PC2min)
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
my_colours <- c("red", "cyan", "yellow", "purple", "green")[subfam1]
# plot the CVA
plot(cva$CVscores, col=my_colours, pch=16,asp=1,
xlab=paste("1st canonical axis", paste(round(cva$Var[1,2],1),"%")),
ylab=paste("2nd canonical axis", paste(round(cva$Var[2,2],1),"%")))
legend("topright", legend=levels(subfam1), col = c("red", "cyan", "yellow", "purple", "green"), pch=16)
require(car)
for(ii in 1:length(levels(subfam1))){
dataEllipse(cva$CVscores[subfam1==levels(subfam1)[ii],1],
cva$CVscores[subfam1==levels(subfam1)[ii],2],
add=TRUE,levels=.95, col=c("red", "cyan", "yellow", "purple", "green")[ii])}
text(cva$CVscores[200,1], cva$CVscores[200,2], as.character(species1[200]), col="black", cex=1, pos=4)
text(cva$CVscores[49,1], cva$CVscores[49,2], as.character(species1[49]), col="black", cex=1, pos=4)
library(Evomorph)
inlist = list(pro_red$coords [,,])
for ( j in 1: dim(pro_red$coords )[3] )
inlist[[j]] = pro_red$coords [,,j]
ID = paste (subfam1,species1, sep = "_", collapse = NULL, recycle0 = FALSE)
### PC1 for PC1dist thingy.. for empty matrix: ###################
PCA_sc<-PCA$pc.scores
row.names(PCA_sc) = ID
PCdist = as.matrix( dist(PCA_sc))
###  make empty matrix
Proc_dist= matrix( NA, dim(PCA_sc)[1], dim(PCA_sc)[1] )
colnames(Proc_dist) = ID
rownames(Proc_dist) = ID
###  make a loop : calculate proc distances for each row.
Proc_dist
for ( i in 1:length(ID)){
Proc_dist[i,] = ShapeDist(inlist, inlist[[i]])
}
write.table(Proc_dist,"Proc_distances_ban_pim_oph_cte.txt", sep=" ",row.names = TRUE, col.names = TRUE)
###################################################################
Proc_dist = read.table("Proc_distances_ban_pim_oph_cte.txt", header=T)
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
my_colours <- c("red", "cyan", "yellow", "purple", "green")[subfam1]
# plot the CVA
plot(cva$CVscores, col=my_colours, pch=16,asp=1,
xlab=paste("1st canonical axis", paste(round(cva$Var[1,2],1),"%")),
ylab=paste("2nd canonical axis", paste(round(cva$Var[2,2],1),"%")))
legend("topright", legend=levels(subfam1), col = c("red", "cyan", "yellow", "purple", "green"), pch=16)
require(car)
for(ii in 1:length(levels(subfam1))){
dataEllipse(cva$CVscores[subfam1==levels(subfam1)[ii],1],
cva$CVscores[subfam1==levels(subfam1)[ii],2],
add=TRUE,levels=.95, col=c("dark yellow", "light blue", "purple", "rosa", "green")[ii])}
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
my_colours <- c("red", "cyan", "yellow", "purple", "green")[subfam1]
# plot the CVA
plot(cva$CVscores, col=my_colours, pch=16,asp=1,
xlab=paste("1st canonical axis", paste(round(cva$Var[1,2],1),"%")),
ylab=paste("2nd canonical axis", paste(round(cva$Var[2,2],1),"%")))
legend("topright", legend=levels(subfam1), col = c("red", "cyan", "yellow", "purple", "green"), pch=16)
require(car)
for(ii in 1:length(levels(subfam1))){
dataEllipse(cva$CVscores[subfam1==levels(subfam1)[ii],1],
cva$CVscores[subfam1==levels(subfam1)[ii],2],
add=TRUE,levels=.95, col=c("yellow", "light blue", "purple", "rosa", "green")[ii])}
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
my_colours <- c("red", "cyan", "yellow", "purple", "green")[subfam1]
# plot the CVA
plot(cva$CVscores, col=my_colours, pch=16,asp=1,
xlab=paste("1st canonical axis", paste(round(cva$Var[1,2],1),"%")),
ylab=paste("2nd canonical axis", paste(round(cva$Var[2,2],1),"%")))
legend("topright", legend=levels(subfam1), col = c("red", "cyan", "yellow", "purple", "green"), pch=16)
require(car)
for(ii in 1:length(levels(subfam1))){
dataEllipse(cva$CVscores[subfam1==levels(subfam1)[ii],1],
cva$CVscores[subfam1==levels(subfam1)[ii],2],
add=TRUE,levels=.95, col=c("yellow", "light blue", "purple", "rose pink", "green")[ii])}
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
my_colours <- c("red", "cyan", "yellow", "purple", "green")[subfam1]
# plot the CVA
plot(cva$CVscores, col=my_colours, pch=16,asp=1,
xlab=paste("1st canonical axis", paste(round(cva$Var[1,2],1),"%")),
ylab=paste("2nd canonical axis", paste(round(cva$Var[2,2],1),"%")))
legend("topright", legend=levels(subfam1), col = c("red", "cyan", "yellow", "purple", "green"), pch=16)
require(car)
for(ii in 1:length(levels(subfam1))){
dataEllipse(cva$CVscores[subfam1==levels(subfam1)[ii],1],
cva$CVscores[subfam1==levels(subfam1)[ii],2],
add=TRUE,levels=.95, col=c("yellow", "light blue", "purple", "light pink", "green")[ii])}
text(cva$CVscores[200,1], cva$CVscores[200,2], as.character(species1[200]), col="black", cex=1, pos=4)
text(cva$CVscores[49,1], cva$CVscores[49,2], as.character(species1[49]), col="black", cex=1, pos=4)
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
my_colours <- c("red", "cyan", "yellow", "purple", "green")[subfam1]
# plot the CVA
plot(cva$CVscores, col=my_colours, pch=16,asp=1,
xlab=paste("1st canonical axis", paste(round(cva$Var[1,2],1),"%")),
ylab=paste("2nd canonical axis", paste(round(cva$Var[2,2],1),"%")))
legend("topright", legend=levels(subfam1), col = c("red", "cyan", "yellow", "purple", "green"), pch=16)
require(car)
for(ii in 1:length(levels(subfam1))){
dataEllipse(cva$CVscores[subfam1==levels(subfam1)[ii],1],
cva$CVscores[subfam1==levels(subfam1)[ii],2],
add=TRUE,levels=.95, col=c("yellow", "light blue", "purple", "pink", "green")[ii])}
text(cva$CVscores[200,1], cva$CVscores[200,2], as.character(species1[200]), col="black", cex=1, pos=4)
text(cva$CVscores[49,1], cva$CVscores[49,2], as.character(species1[49]), col="black", cex=1, pos=4)
ggplot(PCA$pc.scores[,1],PCA$pc.scores[,2], aes(PCA$pc.scores[,1],PCA$pc.scores[,2]))
ggplot(mpg, aes(hwy, cyl)) + geom_point(aes(shape=19, size=cyl))
ggplot(mpg, aes(hwy, cyl)) + geom_point(aes(size=cyl))
ggplot(subfam1, aes(hwy, cyl)) + geom_point(aes(size=cyl))
ggplot(data= "subfam1", aes(hwy, cyl)) + geom_point(aes(size=cyl))
ggplot(mpg=subfam1, aes(hwy, cyl)) + geom_point(aes(size=cyl))
ggplot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=subfam1, asp=T, las=1,pch=16, cex=1.5)
ggplot(PCA$pc.scores[,1],PCA$pc.scores[,2], aes(col=subfam1, asp=T, las=1,pch=16, cex=1.5),
legend("topright", legend= levels(subfam1), col=palette(), pch=rep(19,14)))
ggplot(data = pro_red, mapping= aes(x= PC_Score1, y=PC_Score2))
install.packages("ggfortify")
autoplot(PCA, color= "subfam1")
autoplot(data=PCA, color= "subfam1")
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
my_colours <- c("red", "cyan", "yellow", "purple", "green")[subfam1]
# plot the CVA
plot(cva$CVscores, col=my_colours, pch=16,asp=1,
xlab=paste("1st canonical axis", paste(round(cva$Var[1,2],1),"%")),
ylab=paste("2nd canonical axis", paste(round(cva$Var[2,2],1),"%")))
legend("topright", legend=levels(subfam1), col = c("red", "cyan", "yellow", "purple", "green"), pch=16)
require(car)
for(ii in 1:length(levels(subfam1))){
dataEllipse(cva$CVscores[subfam1==levels(subfam1)[ii],1],
cva$CVscores[subfam1==levels(subfam1)[ii],2],
add=TRUE,levels=.95, col=c("yellow", "light blue", "purple", "pink", "green")[ii])}
text(cva$CVscores[200,1], cva$CVscores[200,2], as.character(species1[200]), col="black", cex=1, pos=4)
text(cva$CVscores[49,1], cva$CVscores[49,2], as.character(species1[49]), col="black", cex=1, pos=4)
my_colours
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
my_colours <- c("yellow", "light blue", "purple", "pink", "green")[subfam1]
# plot the CVA
plot(cva$CVscores, col=my_colours, pch=16,asp=1,
xlab=paste("1st canonical axis", paste(round(cva$Var[1,2],1),"%")),
ylab=paste("2nd canonical axis", paste(round(cva$Var[2,2],1),"%")))
legend("topright", legend=levels(subfam1), col = c("yellow", "light blue", "purple", "pink", "green"), pch=16)
require(car)
for(ii in 1:length(levels(subfam1))){
dataEllipse(cva$CVscores[subfam1==levels(subfam1)[ii],1],
cva$CVscores[subfam1==levels(subfam1)[ii],2],
add=TRUE,levels=.95, col=c("yellow", "light blue", "purple", "pink", "green")[ii])}
text(cva$CVscores[200,1], cva$CVscores[200,2], as.character(species1[200]), col="black", cex=1, pos=4)
text(cva$CVscores[49,1], cva$CVscores[49,2], as.character(species1[49]), col="black", cex=1, pos=4)
#Neuer Versuch an Plot
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=my_colours, pch=16,asp=1,
xlab=paste("1st PC-Score"),
ylab=paste("2nd PC-Score"),
legend("topright", legend=levels(subfam1), col = c("yellow", "light blue", "purple", "pink", "green"), pch=16))
#Neuer Versuch an Plot
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=my_colours, pch=16,asp=1,
legend("topright", legend=levels(subfam1), col = c("yellow", "light blue", "purple", "pink", "green"), pch=16))
#Neuer Versuch an Plot
par(mar=c(4, 4, 1, 1))
my_colours <- c("yellow", "light blue", "purple", "pink", "green")[subfam1]
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=my_colours, pch=16,asp=1,
legend("topright", legend=levels(subfam1), col = c("yellow", "light blue", "purple", "pink", "green"), pch=16))
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=my_colours, asp=T, las=1, pch=16, cex=1.5,
legend("topright", legend=levels(subfam1), col = c("yellow", "light blue", "purple", "pink", "green"), pch=16))
#Nochmals neuer Versuch an Plot
head(PCA)
#Nochmals neuer Versuch an Plot
df_out <- as.data.frame(PCA$pc.scores)
df_out$group <- sapply( strsplit(as.character(row.names(df)), "_"), "[[", 1 )
df_out$subfam1 <- sapply( strsplit(as.character(row.names(df)), "_"), "[[", 1 )
df_out <- as.data.frame(PCA$pc.scores)
df_out$groups <- sapply( strsplit(as.character(row.names(subfam1)), "_"), "[[", 1 )
df <- subfam1[c(1, 2, 3, 4)]
df_out <- as.data.frame(PCA$pc.scores)
df_out$groups <- sapply( strsplit(as.character(row.names(df)), "_"), "[[", 1 )
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
require(Morpho)
require(rgl)
options(rgl.useNULL = TRUE) # Suppress the separate window.
knitr::knit_hooks$set(webgl = hook_webgl)
library(geomorph)
setwd("~/GitHub/Ichneumonidae/R-Scripts/Determine Higher-Grouping")
landmark = readland.tps("blockcourse_highersub.tps",specID = "ID", readcurves = T, warnmsg = TRUE)
##      define classifiers (subfam or tribes)
species = as.factor( substr( dimnames(landmark)[[3]], 1, 6))
subfam = as.factor( substr( dimnames(landmark)[[3]], 8, 13))
areolet = as.factor( substr( dimnames(landmark)[[3]], 15, 15))
tribe = as.factor( substr( dimnames(landmark)[[3]], 17, 19))
##      define Semilandmarks, first LM is the start, last one the end (those are both
##      fixed landmarks, in between are the semilandmarks):
sliders = define.sliders(c(15,22:29,16))
##      procrustes fit - "superimposition" - rotates and scales the landmarks to their closest distance,
##      minimizing the shape and size difference:
proD<-gpagen(landmark, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
use= c("pimpli", "banchi", "phygad", "ophion", "ichneu")
reduced<- proD$coords[,,subfam%in% use]
pro_red<-gpagen(reduced, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
subfam1<-as.factor(substr(dimnames(pro_red$coords)[[3]],8,13))
species1<-as.factor(substr(dimnames(pro_red$coords)[[3]],1,6))
tribe1<-as.factor(substr(dimnames(pro_red$coords)[[3]],17,19))
PCA <-plotTangentSpace(pro_red$coords, groups=subfam1, legend=T)
mat <- matrix(c(4,5,0,1,1,2,1,1,3), 3)
layout(mat, widths=c(1,1,1), heights=c(1,1,1))# set the size of the rows and columns
my_colors = matrix( NA, dim(PCA$pc.scores[,]))
for(i in 1:length( row.names(PCA$pc.scores[,]))){
my_colors[i] <- switch(substr(row.names(PCA$pc.scores[,])[i],8,13), "banchi" = "gold1", "pimpli" = "chartreuse3", "gelina" = "lightpink", "ophion" = "blueviolet", "ichneu" = "lightskyblue")
}
## the more beautiful version:
mat <- matrix(c(4,5,0,1,1,2,1,1,3), 3)
layout(mat, widths=c(1,1,1), heights=c(1,1,1))# set the size of the rows and columns
my_colors = matrix( NA, dim(PCA$pc.scores[,]))
for(i in 1:length( row.names(PCA$pc.scores[,]))){
my_colors[i] <- switch(substr(row.names(PCA$pc.scores[,])[i],8,13), "banchi" = "gold1", "pimpli" = "chartreuse3", "phygad" = "lightpink", "ophion" = "blueviolet", "ichneu" = "lightskyblue")
}
par(mar=c(4, 4, 1, 1)) # sets the margins
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=my_colors, asp=T, las=1,pch=16, cex=1.5)
legend("topright", legend= levels(subfam1), col=palette(), pch=rep(19,14) )
#Neuer Versuch an Plot
par(mar=c(4, 4, 1, 1))
my_colours <- c("yellow", "light blue", "purple", "pink", "green")[subfam1]
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=my_colours, asp=T, las=1, pch=16, cex=1.5,
legend("topright", legend=levels(subfam1), col = c("yellow", "light blue", "purple", "pink", "green"), pch=16))
#CVA
cva<- CVA(pro_red$coords, groups = subfam1, plot= T, rounds= 1000)
<<<<<<< Updated upstream:R-Scripts/Determine Higher-Grouping/Analysis of the subfamilies.Rmd
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
require(Morpho)
require(rgl)
options(rgl.useNULL = TRUE) # Suppress the separate window.
knitr::knit_hooks$set(webgl = hook_webgl)
library(geomorph)
setwd("~/GitHub/Ichneumonidae/R-Scripts/Determine Higher-Grouping")
landmark = readland.tps("blockcourse_highersub.tps",specID = "ID", readcurves = T, warnmsg = TRUE)
##      define classifiers (subfam or tribes)
species = as.factor( substr( dimnames(landmark)[[3]], 1, 6))
subfam = as.factor( substr( dimnames(landmark)[[3]], 8, 13))
areolet = as.factor( substr( dimnames(landmark)[[3]], 15, 15))
tribe = as.factor( substr( dimnames(landmark)[[3]], 17, 19))
##      define Semilandmarks, first LM is the start, last one the end (those are both
##      fixed landmarks, in between are the semilandmarks):
sliders = define.sliders(c(15,22:29,16))
##      procrustes fit - "superimposition" - rotates and scales the landmarks to their closest distance,
##      minimizing the shape and size difference:
proD<-gpagen(landmark, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
use= c("pimpli", "banchi", "phygad", "ophion", "ichneu")
reduced<- proD$coords[,,subfam%in% use]
pro_red<-gpagen(reduced, surfaces = NULL, curves= sliders,
PrinAxes = FALSE, max.iter = NULL, ProcD = F, Proj = TRUE,
print.progress = TRUE)
subfam1<-as.factor(substr(dimnames(pro_red$coords)[[3]],8,13))
species1<-as.factor(substr(dimnames(pro_red$coords)[[3]],1,6))
tribe1<-as.factor(substr(dimnames(pro_red$coords)[[3]],17,19))
PCA <-plotTangentSpace(pro_red$coords, groups=subfam1, legend=T)
## the more beautiful version:
mat <- matrix(c(4,5,0,1,1,2,1,1,3), 3)
layout(mat, widths=c(1,1,1), heights=c(1,1,1))# set the size of the rows and columns
my_colors = matrix( NA, dim(PCA$pc.scores[,]))
for(i in 1:length( row.names(PCA$pc.scores[,]))){
my_colors[i] <- switch(substr(row.names(PCA$pc.scores[,])[i],8,13), "banchi" = "gold1", "pimpli" = "chartreuse3", "phygad" = "lightpink", "ophion" = "blueviolet", "ichneu" = "lightskyblue")
}
par(mar=c(4, 4, 1, 1)) # sets the margins
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=my_colors, asp=T, las=1,pch=16, cex=1.5)
legend("topright", legend= levels(subfam1), col=palette(), pch=rep(19,14) )
#Neuer Versuch an Plot
par(mar=c(4, 4, 1, 1))
my_colours <- c("yellow", "light blue", "purple", "pink", "green")[subfam1]
plot(PCA$pc.scores[,1],PCA$pc.scores[,2], col=my_colours, asp=T, las=1, pch=16, cex=1.5,
legend("topright", legend=levels(subfam1), col = c("yellow", "light blue", "purple", "pink", "green"), pch=16))
